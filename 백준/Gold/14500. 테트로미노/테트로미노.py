import sys

N, M = map(int, sys.stdin.readline().split())                               # N, M을 입력받는다.

L = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]        # 2차원 배열 L을 입력받는다.

shape = [                                                                   # 순수완전탐색으로 문제를 푼다.
    [[0, 0], [0, 1], [1, 0], [1, 1]],                                       # 먼저 회전이나 대칭을 포함한 모든 테트로미노의 경우를 좌표로 생각해서 3차원 배열로 만들어둔다.
    [[0, 0], [0, 1], [0, 2], [0, 3]],
    [[0, 0], [1, 0], [2, 0], [3, 0]],
    [[0, 0], [0, 1], [0, 2], [-1, 2]],
    [[0, 0], [1, 0], [2, 0], [2, 1]],
    [[0, 0], [0, 1], [0, 2], [1, 0]],
    [[0, 0], [0, 1], [1, 1], [2, 1]],
    [[0, 0], [0, 1], [-1, 1], [-1, 2]],
    [[0, 0], [1, 0], [1, 1], [2, 1]],
    [[0, 0], [0, 1], [0, 2], [-1, 1]],
    [[0, 0], [1, 0], [2, 0], [1, 1]],
    [[0, 0], [0, 1], [0, 2], [1, 1]],
    [[0, 0], [0, 1], [-1, 1], [1, 1]],
    [[0, 0], [0, 1], [1, 1], [1, 2]],
    [[0, 0], [1, 0], [1, -1], [2, -1]],
    [[0, 0], [1, 0], [1, 1], [1, 2]],
    [[0, 0], [0, 1], [1, 0], [2, 0]],
    [[0, 0], [0, 1], [0, 2], [1, 2]],
    [[0, 0], [1, 0], [2, 0], [2, -1]]
]

result = 0                                                                  # 최종결과인 result.

for i in range(0, N):                                                       # N x M 모든 좌표를 시작점으로 해서.
    for j in range(0, M):
        for k in range(0, 19):                                              # 19가지의 형태의 테트로미노를 전부 2차원배열에 대본다.
            temp = 0                                                        # 임시로 2차원 배열의 값들을 더한 값을 저장할 temp.
            for e in range(0, 4):                                           # 테트로미노의 4가지 정사각형의 좌표들을 계산해본다.
                x = i + shape[k][e][0]
                y = j + shape[k][e][1]

                if x < 0 or x > N-1 or y < 0 or y > M-1:                    # 테트로미노의 4가지의 좌표를 검사해서 만약 2차원 배열 L의 인덱스를 초과하거나 0보다 작게될 경우.
                    temp = 0                                                # 이 경우의 temp를 0으로 만들어 없애버린 후에 break로 다음 형태의 테트로미노로 넘긴다.
                    break

                temp = temp + L[x][y]                                       # 만약 2차원 배열 L의 인덱스 안에서 테트로미노의 형태가 성립할 경우 4개의 값이 temp에 더해지는데.

            result = max(result, temp)                                      # 이를 계속 result와 비교하면서 모든 좌표에서 19가지의 형태를 전부 대입해봐서 최대값을 도출한다.

print(result)                                                               # 최종결과 출력!